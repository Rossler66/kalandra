<?phpclass repository {    protected $definice;    protected $where;    protected $order;    protected $having;    protected $group;    protected $limit;    protected $offset;    protected $pocetEle;    public function setWhere($where) {        $this->where = $where;    }    public function addWhere($where, $napojeni) {        if ($this->where > "") {            $this->where .= " " . $napojeni . " " . $where;        } else {            $this->where = $where;        }    }    public            function setOrder($order) {        $this->order = $order;    }    public            function addOrder($order) {        $this->order .= ", " . $order;    }    public            function setGroup($group) {        $this->group = $group;    }    public            function addGroup($group) {        $this->group .= ", " . $group;    }    public            function setHaving($having) {        $this->having = $having;    }    public            function setLimit($limit) {        $this->limit = $limit;    }    function setOffset($offset) {        $this->offset = $offset;    }    public function setJoin($alias, $join) {        $this->definice[$alias]["join"] = $join;    }    public function addJoin($alias, $join, $vazba) {        $this->definice[$alias]["join"] .= " " . $vazba . " " . $join;    }    public function set($param) {        $this->clear();        foreach ($param as $klic => $hodnota) {            if ($klic == "where") {                $this->setWhere($param["where"]);            }            if ($klic == "order") {                $this->setOrder($param["order"]);            }            if ($klic == "having") {                $this->setHaving($param["having"]);            }            if ($klic == "group") {                $this->setGroup($param["group"]);            }            if ($klic == "limit") {                $this->setLimit($param["limit"]);            }            if ($klic == "offset") {                $this->setOffset($param["offset"]);            }            if ($klic == "join") {                foreach ($param["join"] as $alias => $join) {                    $this->definice[$alias]["join"] .= $join;                }            }        }    }    public function clear() {        $this->where = "";        $this->order = "";        $this->having = "";        $this->group = "";        $this->limit = 30;        $this->offset = 0;        $this->pocetEle = 0;    }    public function pocet($vyp = 0) {        //Naplnění proměnných          $where = " WHERE "; //oddělovač where        $join = ""; //všechny JOIN v selectu        //sestaví názvy načítaných položek pro hlavní tabulku        $polozky = " count(*) as pocet ";        $join = "";        if (!is_array($this->definice)) {            $this->definice = array();        }        foreach ($this->definice as $def) {            if ($def["join"]) {                $join .= " LEFT JOIN " . $def["tabulka"] . " as " . $def["alias"] . " ON (" . $def["join"] . ") ";            } else {                $hlavni = $def["alias"];            }        }        //Sestaví konečnou podobu SQLu        $SQL = " SELECT " . $polozky;        $SQL .= " FROM " . $this->definice[$hlavni]["tabulka"] . " " . $this->definice[$hlavni]["alias"] . " " . $join;        //Sestaví konečnou podobu SQLu        $SQL = " SELECT " . $polozky;        $SQL .= " FROM " . $this->definice[$hlavni]["tabulka"] . " " . $this->definice[$hlavni]["alias"] . " " . $join;        if ($this->where) {            $SQL .= $where . $this->where;            $where = " AND ";        }        if ($this->group) {            $SQL .= " GROUP BY " . $this->group;        }        if ($this->having) {            $SQL .= " HAVING " . $this->having;        }        //načte SQL z databáze a pokud je chyba vrání null        if ($vyp == 1) {            echo $SQL . "<br />";        }        //        echo $SQL."<br />";        $Q = db::query($SQL);        if (db::error()) {            return null;        }        $P = $Q->fetch_assoc();        return $P["pocet"];    }    //Naplní a vrátí entity definovaným selectem    //Parametry    // definice - definice selectu    //Vrací: pole načtených entit. Pokud je načítáno více druhů entit jsou ve vracném poli pod názvem aliasu.    //  to platí i pro jednu entitu. Při načítání více stejných entit jsou v poli v prvním indexu, který je číselný    public function nacti($prazdna = false) {        //Naplnění proměnných          $where = " WHERE "; //oddělovač where        $join = ""; //všechny JOIN v selectu        $entity = array(); //Pole vracených načtených entit        //sestaví názvy načítaných položek pro hlavní tabulku        $polozky = "";        $join = "";        $odd = "";        if (!is_array($this->definice)) {            $this->definice = array();        }        foreach ($this->definice as $def) {            $polozky .= $odd . $this->entitaPolozky($def);            if (array_key_exists("addpol",$def) && $def["addpol"]) {                $polozky .= "," . $def["addpol"];            }            $odd = ", ";            if (array_key_exists("join",$def) && $def["join"]) {                $join .= " LEFT JOIN " . $def["tabulka"] . " as " . $def["alias"] . " ON (" . $def["join"] . ") ";            } else {                $hlavni = $def["alias"];            }        }        //Sestaví konečnou podobu SQLu        $SQL = " SELECT " . $polozky;        $SQL .= " FROM " . $this->definice[$hlavni]["tabulka"] . " " . $this->definice[$hlavni]["alias"] . " " . $join;        if ($this->where) {            $SQL .= $where . $this->where;            $where = " AND ";        }        if ($this->group) {            $SQL .= " GROUP BY " . $this->group;        }        if ($this->having) {            $SQL .= " HAVING " . $this->having;        }        if ($this->order) {            $SQL .= " ORDER BY " . $this->order;        }        if ($this->limit) {            $offset = $this->offset * $this->limit;            if ($this->offset == null) {                $this->offset = 0;            }            $SQL .= " LIMIT " . $offset . ", " . $this->limit;        }        $zaznamy = db::query($SQL);        $this->pocetEle = $zaznamy->num_rows;        $this->pocetEle = 1;        if (db::error() || $this->pocetEle == 0) {            if ($prazdna) {                return $this->vratEntitu(null);            } else {                return null;            }        }        //načte pro jednotlivé záznamy SQLu entity a uloží je do výstupního pole        while ($zaznam = $zaznamy->fetch_assoc()) {            //vytvoří pole pro entity halvní a podřízených tabulek.             $ent = array();            /*              //Do pole entity vloží entitu hlavního záznamu              $ent[$this->definice["hlavni"]["alias"]] = $this->naplnEntituSQL($zaznam, $this->definice["hlavni"]);              //Projde navázané záznamy a do pole entity vloží entity navázaných záznamů              foreach ($this->definice["navazane"] as $navazana) {              $ent[$navazana["alias"]] = $this->naplnEntituSQL($zaznam, $navazana);              }             */            if (!is_array($this->definice)) {                $this->definice = array();            }            foreach ($this->definice as $def) {                $ent[$def["alias"]] = $this->naplnEntituSQL($zaznam, $def);            }            //Sestavené pole entit hlavních a podřízených záznamů vloží do sesznamu entitu            array_push($entity, $ent);        }        return $entity;    }    //Naplní a vrátí entity definovaným selectem    //Parametry    // definice - definice selectu    //Vrací: pole načtených entit. Pokud je načítáno více druhů entit jsou ve vracném poli pod názvem aliasu.    //  to platí i pro jednu entitu. Při načítání více stejných entit jsou v poli v prvním indexu, který je číselný    public function nactiQ($SQL, $vyp = 0) {        $entity = array();        $zaznamy = db::query($SQL);        $this->pocetEle = $zaznamy->num_rows;        if (db::error() || $this->pocetEle == 0) {            return null;        }        //načte pro jednotlivé záznamy SQLu entity a uloží je do výstupního pole        while ($zaznam = $zaznamy->fetch_assoc()) {            //vytvoří pole pro entity halvní a podřízených tabulek.             $ent = array();            /*              //Do pole entity vloží entitu hlavního záznamu              $ent[$this->definice["hlavni"]["alias"]] = $this->naplnEntituSQL($zaznam, $this->definice["hlavni"]);              //Projde navázané záznamy a do pole entity vloží entity navázaných záznamů              foreach ($this->definice["navazane"] as $navazana) {              $ent[$navazana["alias"]] = $this->naplnEntituSQL($zaznam, $navazana);              }             */            if (!is_array($this->definice)) {                $this->definice = array();            }            foreach ($this->definice as $def) {                $ent[$def["alias"]] = $this->naplnEntituSQL($zaznam, $def);            }            //Sestavené pole entit hlavních a podřízených záznamů vloží do sesznamu entitu            array_push($entity, $ent);        }        return $entity;    }    //Naplní a vrátí entity definovaným selectem    //Parametry    // definice - definice selectu    //Vrací: pole načtených entit. Pokud je načítáno více druhů entit jsou ve vracném poli pod názvem aliasu.    //  to platí i pro jednu entitu. Při načítání více stejných entit jsou v poli v prvním indexu, který je číselný    public function sqlPolozky($polozky, $vyp = 0) {        //Naplnění proměnných          $where = " WHERE "; //oddělovač where        $join = ""; //všechny JOIN v selectu        $entity = array(); //Pole vracených načtených entit        //sestaví názvy načítaných položek pro hlavní tabulku        $join = "";        $odd = "";        if (!is_array($this->definice)) {            $this->definice = array();        }        foreach ($this->definice as $def) {            $polozky .= $odd . $this->entitaPolozky($def);            $odd = ", ";            if ($def["join"]) {                $join .= " LEFT JOIN " . $def["tabulka"] . " as " . $def["alias"] . " ON (" . $def["join"] . ") ";            } else {                $hlavni = $def["alias"];            }        }        //Sestaví konečnou podobu SQLu        $SQL = " SELECT " . $polozky;        $SQL .= " FROM " . $this->definice[$hlavni]["tabulka"] . " " . $this->definice[$hlavni]["alias"] . " " . $join;        if ($this->where) {            $SQL .= $where . $this->where;            $where = " AND ";        }        if ($this->group) {            $SQL .= " GROUP BY " . $this->group;        }        if ($this->having) {            $SQL .= " HAVING " . $this->having;        }        if ($this->order) {            $SQL .= " ORDER BY " . $this->order;        }        if ($this->limit) {            $offset = $this->offset * $this->limit;            if ($this->offset == null) {                $this->offset = 0;            }            $SQL .= " LIMIT " . $offset . ", " . $this->limit;        }        //načte SQL z databáze a pokud je chyba vrání null        if ($vyp == 1) {            echo $SQL . "<br />";        }        $zaznamy = db::query($SQL);        $this->pocetEle = $zaznamy->num_rows;        if (db::error() || $this->pocetEle == 0) {            return null;        }        //načte pro jednotlivé záznamy SQLu entity a uloží je do výstupního pole        while ($zaznam = $zaznamy->fetch_assoc()) {            //vytvoří pole pro entity halvní a podřízených tabulek.             $ent = array();            /*              //Do pole entity vloží entitu hlavního záznamu              $ent[$this->definice["hlavni"]["alias"]] = $this->naplnEntituSQL($zaznam, $this->definice["hlavni"]);              //Projde navázané záznamy a do pole entity vloží entity navázaných záznamů              foreach ($this->definice["navazane"] as $navazana) {              $ent[$navazana["alias"]] = $this->naplnEntituSQL($zaznam, $navazana);              }             */            if (!is_array($this->definice)) {                $this->definice = array();            }            foreach ($this->definice as $def) {                $ent[$def["alias"]] = $this->naplnEntituSQL($zaznam, $def);            }            //Sestavené pole entit hlavních a podřízených záznamů vloží do sesznamu entitu            array_push($entity, $ent);        }        return $entity;    }    //Uloží předanou entitu do databáze    //Parametry    // entity - matice ukládaných entit    // definice - definice, která obsahuje název tabulky a alias ukládané entity    public function uloz($entita, $alias, $polozky = null) {        //Projde všechny entity        if ($entita->id < 1) {            $SQL = "INSERT INTO " . $this->definice[$alias]["tabulka"] . " " . $entita->vratPolozkyInsert($polozky);            db::query($SQL);            $entita->id = db::insertId();        }        //Entita má ID - provede UPDATE        else {            $SQL = "UPDATE " . $this->definice[$alias]["tabulka"] . " SET " . $entita->vratPolozkyUpdate($polozky) .                    " WHERE id = '" . $entita->id . "'";            //            echo $SQL . "<br />";            db::query($SQL);        }    }    //Uloží předanou entitu do databáze výhradně příkazem insert    //Parametry    // entity - matice ukládaných entit    // definice - definice, která obsahuje název tabulky a alias ukládané entity    public function insert($entita, $alias) {        $SQL = "INSERT INTO " . $this->definice[$alias]["tabulka"] . " " . $entita->vratPolozkyInsert();        //            echo $SQL . "***<br />";        db::query($SQL);        if (!$entita->id) {            $entita->id = db::insertId();        }    }    //Uloží předanou entitu do databáze výhradně příkazem insert    //Parametry    // entity - matice ukládaných entit    // definice - definice, která obsahuje název tabulky a alias ukládané entity    public function insertignore($entita, $alias) {        $SQL = "INSERT IGNORE INTO " . $this->definice[$alias]["tabulka"] . " " . $entita->vratPolozkyInsert();        //            echo $SQL . "***<br />";        db::query($SQL);        if (!$entita->id) {            $entita->id = db::insertId();        }    }    //Smaže předanou entitu z databáze    //Parametry    // entity - matice mazaných entit    // definice - definice, která obsahuje název tabulky a alias mazané entity    public function smaz($entita, $alias) {        //Projde všechny entity        //        foreach ($entity as $entita) {        //Entita má ID a smaže se        if ($entita->id > 0) {            $SQL = "DELETE FROM " . $this->definice[$alias]["tabulka"] .                    " WHERE id = '" . $entita->id . "'";            //            echo $SQL . "***<br />";            db::query($SQL);        }        //      }    }    //Vrací pole pro všechny entity z definice    public function vratEntitu($entity) {        if ($entity == null) {            $entity = array();        }        //vytvoří pole pro entity halvní a podřízených tabulek.         $ent = array();        //Do pole entity vloží entitu hlavního záznamu        if (!is_array($this->definice)) {            $this->definice = array();        }        foreach ($this->definice as $def) {            $ent[$def["alias"]] = new $def["entita"]();        }        //Sestavené pole entit hlavních a podřízených záznamů vloží do sesznamu entitu        array_push($entity, $ent);        return $entity;    }    public function pocetEle() {        return $this->pocetEle;    }    //Vrátí položky entits s aliasem oddělené čátkou (pro SELECT)    //parametr    // definice - definice záznamu s názvem entity a aliasu    private function entitaPolozky($definice) {        $ent = new $definice["entita"]();        if(!array_key_exists("polozky",$definice)){            $definice["polozky"] = null;        }        return $ent->vratPolozkySelect($definice["alias"], $definice["polozky"]);    }    //Naplní entitu z načteného záznamu    //Parametry    // zaznam - načtný záznam SQL příkazem SELECT    // definice - definice hlavní nebo navázané tabulky, kde je název entity a alias    private function naplnEntituSQL($zaznam, $definice) {        //Založí entitu pro tabulku        $ent = new $definice["entita"]();        //Načte z entity názvy položek        $polozky = $ent->vratPolozky();        //Pro každý název položky naplní položku z ze záznamu        if (!is_array($polozky)) {            $polozky = array();        }        foreach ($polozky as $key => $pol) {            //            echo $key.":".$pol.":".$zaznam[$this->definice["alias"] . "__" . $key]."<br />";            $ent->$key = $zaznam[$definice["alias"] . "__" . $key];        }        if (array_key_exists("addpolnaz",$definice) && $definice["addpolnaz"]) {            $polnaz = explode(",", $definice["addpolnaz"]);            foreach ($polnaz as $key) {                $ent->$key = $zaznam[$definice["alias"] . "__" . $key];            }        }        //Vrací načtenou entitu        return $ent;    }    public function nactiFormular($vstup) {        $ent = $this->vratEntitu(NULL);        if (!is_array($vstup)) {            $vstup = array();        }        foreach ($vstup as $key => $hod) {            list( $ele, $pro ) = explode("_", $key);            if ($pro && array_key_exists($ele,$ent[0])) {                if (is_array($hod)) {                    $ent[0][$ele]->$pro = db::escape($hod[0]);                } else {                    $ent[0][$ele]->$pro = db::escape($hod);                }            }        }        return $ent;    }    }